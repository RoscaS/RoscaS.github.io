---
layout: post
title: "Py: yield & générateurs"
subtitle: "Mot clé yield et les générateurs en Python"
date: 2017-07-25
author: Sol
category: Py
tags: divers, fr, en
finished: false
---
#### sources
* [larousse.fr](http://www.larousse.fr/dictionnaires/anglais-francais/yield/625276)
* [sam&max](http://sametmax.com/comment-utiliser-yield-et-les-generateurs-en-python/)

## Traduction

#### yield $$ \Rightarrow $$ transitive verb (_conjugaison_)
1.	`produce, bring in`   
    * _conjugaison_ produire
    * _conjugaison_ rapporter  
`- land, crops` produire, rapporter, donner  
`- results` donner 
    * the investment bond will **yield** 11% $$ \Rightarrow $$  le bon d'épargne **rapportera** 11 %  
    * their research has **yielded** some interesting results $$ \Rightarrow $$  leur recherche a **fourni** OR **donné** quelques résultats intéressants
2.	`relinquish, give up` 
    *  céder, 
    *  abandonner  
    to **yield** ground military (figurative) $$ \Rightarrow $$  **céder** du terrain
3.	(US) cars  
 to **yield** right of way $$ \Rightarrow $$ **céder** la priorité

#### yield $$ \Rightarrow $$ noun
1. agriculture & industry 
* `output` rendement m, 
* rapport m * `of crops` récolte f
    * high-**yield** crops $$ \Rightarrow $$ récoltes à **rendement** élevé 
    * yield per acre $$ \Rightarrow $$  **rendement** à l'hectare
2.	finance 
* `from investments` rapport m, rendement m 
* `profit`   bénéfice m, bénéfices mpl 
* `from tax`   recette f, rapport m  
an 8% **yield** on investments $$ \Rightarrow $$  des investissements qui **rapportent** 8 %

#### Autres
* **yield** sign $$ \Rightarrow $$ panneau de priorité
* he **yield** himself up to the police $$ \Rightarrow $$ il s'est **livré** à la police
* to **yield** a secret $$ \Rightarrow $$ **révéler** un secret

## Itérables

Lister un par un les éléments d'une liste $$ \Rightarrow $$ **Itérer** sur les éléments d'une liste

```python
>>> l = [1, 2, 3]
>>> for i in l:
...    print(i)
...
1
2
3
```

Avec une list comprehension, on crée une liste, donc un **itérable**. Avec une boucle `for`, on opère sur ses élèments un par un $$ \Rightarrow $$ on **itère** dessus.

```python
>>> l = [x for x in range(3)]
>>> for i in l:
...     print(i)
...
0
1
2
```

**À chaque fois qu'on peut utiliser `for`...`in` sur quelque chose, c'est un itérable: list, str, queue...**
* pratique $$ \Rightarrow $$ on peut les lire autant qu'on veut
* tous les élèments sont stockés en mémoire $$ \Rightarrow $$ peut être un problème

## Générateurs

La syntaxe d'une **expression génératrice** ressemble à une list comprehension à la différence qu'on utilise `()` à la place de `[]`. La grosse différence est qu'**on ne peut pas lire un générateur plus d'une fois**.

<span style="color:red"> Le principe des générateurs c'est qu'ils génèrent tout à la volée et ne stock pas cette donnée en mémoire </span> 

```python
def display(generateur):
    print("start")
    for i in generateur:
        print(i)
    print("end")

generateur = (x for x in range(3))

print("Premier appel de la fonction:")
display(generateur)

print("Second appel de la fonction:")
display(generateur)
```

output:

```python
Premier appel de la fonction:
start
0
1
2
end
Second appel de la fonction:
start
end
```

On constate dans cet exemple qu'une fois que le générateur est utilisé une première fois, il ne contient plus rien pour le second appel.

## Mot clé yield

Le mot clé `yield` est utilisé en lieu et place de `return` à la différence près qu'on va récupérer un générateur.

```python
>>> def creerGenerateur():
...    mylist = range(3)
...    for i in mylist:
...        yield i
...
>>> contient_generateur = creerGenerateur() # crée un générateur
>>> print(contient_generateur) # generateur est un objet
<generator object creerGenerateur at 0x7f69a52b3308>
>>> for i in contient_generateur:
...     print(i)
0
1
2
```

<span style="color:red"> **TRES IMPORTANT !** </span> 

Ce qu'**il est important de comprendre** dans cet exemple c'est que comme nous utilisons `yield` et non pas `return`, <span style="color:red"> **lors de l'appel de la fonction, le code de la fonction n'est pas exécuté** </span> et a la place, la fonction retourne un objet générateur.

* L'appel `creerGenerateur()` n'exécute pas le code dans le corp de sa définition (`def creerGenerateur()`)
* `creerGenerateur()` retourne un objet de type **generator object**

* Une fois dans la variable `contient_generateur`, tant qu'on ne l'utilise pas, il ne se passe rien ce n'est qu'une fois qu'on commence à itérer sur l'objet de type **generator object** que le code de la fonction s'exécute.

* La première fois que le code s'éxécute (cad une fois qu'on commence à itérer sur `contient_generateur`), il va partir du début de la fonction, arriver jusqu'à `yield` et retrouner la première valeur. Ensuite, à chaque nouveau tour de boucle, le code va reprendre la où il s'est arrêté. (**Python sauvegarde l'état du code du générateur entre chaque appel**), et exécute le code à nouveau jusqu'à ce qu'il rencontre `yield`. Donc dans notre cas il va faire un tour de boucle.

##### Complément d'info sur `l = range(x)`:

```python
>>> l = range(3)
>>> print(l)
range(0, 3)
>>>
>>> print(type(l))
<class 'range'>
>>>
>>> for i in l:
...    print(i)
...
0
1
2
```

