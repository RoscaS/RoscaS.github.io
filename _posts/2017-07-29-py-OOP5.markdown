---
layout: post
title: "Py: OOP 5 Héritage multiple, composition, délégation"
subtitle: "Programmation orienté objet"
date: 2017-07-29
author: Sol
category: Py
tags: divers, fr, en
finished: false
---

#### sources
* [sam&max](http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/)

# Héritage multiple

Dans un jeux vidéo, nous avons des protections et des armes pour les personnages:

```python
class Arme(object):
    def __init__(self, nom, degat):
        self.nom   = nom
        self.degat = degat
    
    def attaque(self, cible):
        cible.vie -= self.degat

class Protection(object):
    def __init__(self, nom, armure):
        self.nom    = nom
        self.armure = armure
    
    def defend(self, degat): # mitige dégats
        degat -= self.armure
        if degat < 0:
            return 0
        return degat

epee   = Arme('Epée de ouf', degat = 999)
casque = Protection('Casque stylé', armure=1)
```

La concurence est rude et on est à la traine. Il faut implémenter un barbar dans le jeu qui puisse taper avec son bouclier.

Une solution serait de créer une nouvelle classe qui hérite des deux classes en même temps:

```python
class ProtectionOffensive(Arme, Protection):
    def __init__(self, nom, degat, armure):
        Arme.__init__(self, nom, degat)        # appel __init__ Arme
        Protection.__init__(self, nom, armure) # appel __init__ Protection
```

Comme on a appelé les deux `__init__`, on va avoir les attributs settés dans les deux `__init__` attachés à cette classe.

Nous avons donc une classe qui possède les méthodes des deux classes parentes:

```python
>>>bouclier = ProtectionOffensive('Bouclier en taule', degat=10, armure=100)
>>>print("degats bouclier:",bouclier.degat)
degats bouclier: 10
>>>print("armure bouclier:",bouclier.armure)
armure bouclier: 100
>>>print("bouclier.defend(214), degats restants:",bouclier.defend(214))
bouclier.defend(214), degats restants: 114
```

Les deux classes parentes ont une méthode `__init__` mais **Python ne peut en "copier" qu'une seule** dans l'enfant. Il copie donc la première qu'il trouve. Il va prendre la liste des parents (class C**(A, B)**:) et la lire de gauche à droite. Il va regarder chaque parent, et si la méthode `__init__` existe la **"**copier**"** dans l'enfant. Si il retrouve une méthode de même nom dans un des parents suivant, **il l'ignore**.

Dans notre exemple, si on fait:

```python
class ProtectionOffensive(Arme, Protection):
    pass
```

`ProtectionOffensive` n'aura que la méthode `__init__` de `Arme` **et ce n'est pas ce qu'on veut**. On va donc override la méthode `__init__` de `ProtectionOffensive`, et dedans appeler la méthode `__init__` de `Arme` **et** de `Protection`.

Cette syntaxe: `Classe.methode(self, args...)` que l'on retrouve dans `Arme.__init__(self, nom, degat)` est juste un moyen d'**appeler spécifiquement la méthode du parent**.

Dans la partie précédente nous avons vu qu'on pouvait faire cela avec `super()`. Mais `super()` **nous retournera la première méthode du premier parent qu'elle trouve**. C'est le but de `super()`, de faire ça automatiquement sans se soucier de savoir qui est le premier parent à avoir une méthode du bon nom.

rappel syntaxe `super()`:

```python
class Enfant(Parent):
    def calcule_complique(self, liste, ristourne):
        prix = super(Enfant, self).calcule_complique(liste)
        return prix - (prix * ristourne / 100)
```

C'est utile car parfois c'est le parent du parent du parent qui a la méthode qu'on veut appeler, on ne connaît pas forcément son nom, ou alors on ne veut pas l'hard coder. Dans notre cas, on veut spécifiquement une méthode d'un parent en particulier, il faut donc l'écrire à la main.

De façon générale:

* On utilise `super()` quand on fait de l'héritage simple où qu'on veut juste appeler la méthode du premier parent venu sans se soucier de son nom (car il peut être très haut dans la chaîne d'héritage).
* On utilise `Classe.methode(self, args...)` quand on veut spécifiquement appeler la méthode d'un parent en particulier.

<span style="color:red"> **ATTENTION** </span> 

Le `self` n'est pas au même endroit dans les cas suivants:

* `super(ClasseCourante, self).methode(args...)` $$ \Rightarrow $$ On passe la classe courante (que `super()` va analyser pour trouver les parents automatiquement)
* `ClasseParente.methode(self, args...)` $$ \Rightarrow $$ On hard code le nom de la classe parente.

## Exemple récapitulatif

```python
class A(object):
    def __init__(self, name, val_a):
        self.name  = name
        self.val_a = val_a
    
    @property
    def methodA(self):
        return ("name: {}\tval_a: {}"
            .format(self.name, self.val_a))
    
    def methodForE(self):
        return ("\nE don't know that A exist...")

class B(object):
    def __init__(self, name, val_b):
        self.name  = name
        self.val_b = val_b
    
    @property
    def methodB(self):
        return ("name: {}\tval_b: {}"
            .format(self.name, self.val_b))

class C(A,B):
    def __init__(self, nom, val_a, val_b):
        A.__init__(self, nom, val_a)
        B.__init__(self, nom, val_b)
    
    @property
    def methodC(self):
        return ("name: {}\tval_a: {}\tval_b: {}"
            .format(self.name, self.val_a, self.val_b))


class D(C):
    pass

class E(D):
    @property
    def methodForE(self):
        first = super(E, self).methodForE()
        return ("{}\n...but still can override a method from it."
            .format(first))
```

```python
objectA = A("objectA", "a")
objectB = B("objectB", "b")
objectC = C("objectC", "a(C)", "b(C)")
objectD = D("objectD", "a(D)", "b(D)")
objectE = E("objectE", "a(E)", "b(E)")

print(objectA.methodA)
print(objectB.methodB)
print(objectC.methodC)

print("\nobjectC also have acces to both methodA and methodB:")
print(objectC.methodA)
print(objectC.methodB)
```

**output**:

```
name: objectA   val_a: a
name: objectB   val_b: b
name: objectC   val_a: a(C)     val_b: b(C)

objectC also have acces to both methodA and methodB:
name: objectC   val_a: a(C)
name: objectC   val_b: b(C)
```

```python
print("\nobjectD have acces to methodC:")
print(objectD.methodC)

print("\nobjectD also have acces to both methodA and methodB:")
print(objectD.methodA)
print(objectD.methodB)
```

**output**:

```
objectD have acces to methodC:
name: objectD   val_a: a(D)     val_b: b(D)

objectD also have acces to both methodA and methodB:
name: objectD   val_a: a(D)
name: objectD   val_b: b(D)
```

```python
print("\nobjectE have acces to methodC:")
print(objectE.methodC)

print("\nobjectE also have acces to both methodA and methodB:")
print(objectE.methodA)
print(objectE.methodB)

print(objectE.methodForE)
```

**output**:

```
objectE have acces to methodC:
name: objectE   val_a: a(E)     val_b: b(E)

objectE also have acces to both methodA and methodB:
name: objectE   val_a: a(E)
name: objectE   val_b: b(E)

E don't know that A exist...
...but still can override a method from it.
```