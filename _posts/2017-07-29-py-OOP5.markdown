---
layout: post
title: "Py: OOP 5 Héritage multiple, composition, délégation"
subtitle: "Programmation orienté objet"
date: 2017-07-29
author: Sol
category: Py
tags: divers, fr, en
finished: false
---

#### sources
* [sam&max](http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/)

# Héritage multiple

Dans un jeux vidéo, nous avons des protections et des armes pour les personnages:

```python
class Arme(object):
    def __init__(self, nom, degat):
        self.nom   = nom
        self.degat = degat
    
    def attaque(self, cible):
        cible.vie -= self.degat

class Protection(object):
    def __init__(self, nom, armure):
        self.nom    = nom
        self.armure = armure
    
    def defend(self, degat): # mitige dégats
        degat -= self.armure
        if degat < 0:
            return 0
        return degat

epee   = Arme('Epée de ouf', degat = 999)
casque = Protection('Casque stylé', armure=1)
```

La concurence est rude et on est à la traine. Il faut implémenter un barbar dans le jeu qui puisse taper avec son bouclier.

Une solution serait de créer une nouvelle classe qui hérite des deux classes en même temps:

```python
class ProtectionOffensive(Arme, Protection):
    def __init__(self, nom, degat, armure):
        Arme.__init__(self, nom, degat)        # appel __init__ Arme
        Protection.__init__(self, nom, armure) # appel __init__ Protection
```

Comme on a appelé les deux `__init__`, on va avoir les attributs settés dans les deux `__init__` attachés à cette classe.

Nous avons donc une classe qui possède les méthodes des deux classes parentes:

```python
>>>bouclier = ProtectionOffensive('Bouclier en taule', degat=10, armure=100)
>>>print("degats bouclier:",bouclier.degat)
degats bouclier: 10
>>>print("armure bouclier:",bouclier.armure)
armure bouclier: 100
>>>print("bouclier.defend(214), degats restants:",bouclier.defend(214))
bouclier.defend(214), degats restants: 114
```

Les deux classes parentes ont une méthode `__init__` mais **Python ne peut en "copier" qu'une seule** dans l'enfant. Il copie donc la première qu'il trouve. Il va prendre la liste des parents (ici: Arme, Protection) et la lire de gauche à droite. Il va regarder chaque parent, et si la méthode existe, il va la "copier" dans l'enfant. Si il retrouve une méthode de même nom dans un des parents suivant, il l'ignore.

Dans notre exemple, si on fait:

```python
class ProtectionOffensive(Arme, Protection):
    pass
```

`ProtectionOffensive` n'aura que la méthode `__init__` de `Arme`. Or ce n'est pas ce qu'on veut. On va donc override la méthode `__init__`, et dedans appeler la méthode `__init__` de `Arme` **et** celle de `Protection`.

Cette syntaxe: `Classe.methode(self, args...)` que l'on retrouve dans `Arme.__init__(self, nom, degat)` est juste un moyen d'appeler spécifiquement la méthode du parent.

Dans la partie précédente nous avons vu qu'on pouvait faire cela avec `super()`. Mais `super()` nous retournera la première méthode du premier parent qu'elle trouve: c'est le but de `super()`, de faire ça automatiquement sans se soucier de savoir qui est le premier parent à avoir une méthode du bon nom.

C'est utile car parfois c'est le parent du parent du parent qui a la méthode qu'on veut appeler, on ne connaît pas forcément son nom, ou alors on ne veut pas l'hard coder. Dans notre cas, on veut spécifiquement une méthode d'un parent en particulier, il faut donc l'écrire à la main.

De façon générale:

* On utilise `super()` quand on fait de l'héritage simple où qu'on veut juste appeler la méthode du premier parent venu sans se soucier de son nom (car il peut être très haut dans la chaîne d'héritage).
* On utilise `Classe.methode(self, args...) quand on veut spécifiquement appeler la méthode d'un parent en particulier.

<span style="color:red"> **ATTENTION** </span> 

Le `self` n'est pas au même endroit dans `super(ClasseCourante, self).methode(args...)` et `ClasseParente.methode(self, args...)`. Dans le premier cas, on passe la classe courante (que `super()` va analyser pour trouver les parents automatiquement) et dans le second, on hard code le nom de la classe parente.

