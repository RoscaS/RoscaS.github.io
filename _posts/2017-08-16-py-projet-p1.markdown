---
layout: post
title: "Py: remake projet p1"
subtitle: "remake du projet p1"
date: 2017-08-17
author: Sol
category: Py
tags: divers, fr, en
finished: false
---

## Repo

* [py_projet_p1](https://github.com/RoscaS/py_projet_p1)

## Traitement liste de points

En sortie de la méthode `coords()` de la classe `ProcessImg` les points sont classés ligne par ligne dans une liste. Chaque ligne est référencée par un pixel de l'axe y de notre image. 

Il faut faire en sorte que le dessin soit fluide et ressemble à la façon de dessiner d'un humain et non pas à celle d'une imprimante.
En gros, il nous faut **Trouver une ligne qui connecte tous les points de la liste**.

[Shortest path problem in a graph, where](https://stackoverflow.com/questions/37742358/sorting-points-to-form-a-continuous-line):
1. the graph nodes are the points in the space, 
2. each node is connected to its 2 nearest neighbors, and 
3. the shortest path passes through each of the nodes only once. That last constrain is a very important (and quite hard one to optimize). 


## Conversion image

## Trouver les points d'intersection de deux cercles (angle du bras)

![alt](http://www.vb-helper.com/howto_circle_circle_intersection1.png)

* [text](https://stackoverflow.com/questions/3349125/circle-circle-intersection-points)





### Liste de points (solution obsolete, openCV is the go!)

```python
from PIL import Image
import tkinter as tk

i = Image.open("aa.png")

pixels = i.load()
width, height = i.size

coords = []

for x in range(width):
    for y in range(height):
        cpixel = pixels[x, y]
        bw_value = int(round(sum(cpixel) / float(len(cpixel))))
        if bw_value != 255:
            # (x, y, (r,g,b))
            coords.append((x, y, cpixel))

canvas_width  = width
canvas_height = height

master = tk.Tk()

w = tk.Canvas(master, width=canvas_width, height=canvas_height)

w.pack()

for i in coords:
    x1, y1 = i[0] - 1, i[1] - 1
    x2, y2 = i[0] + 1, i[1] + 1
    w.create_oval(x1, y1, x2, y2, fill="black")
    

tk.mainloop()
```

### Variantes

#### monochrome

```python
cpixel = pixels[x, y]
bw_value = int(round(sum(cpixel) / float(len(cpixel))))
# the above could probably be bw_value = sum(cpixel)/len(cpixel)
all_pixels.append(bw_value)
```

#### luminance (weighted average)

```python
cpixel = pixels[x, y]
luma = (0.3 * cpixel[0]) + (0.59 * cpixel[1]) + (0.11 * cpixel[2])
all_pixels.append(luma)
```

#### pure 1-bit black and white

```python
cpixel = pixels[x, y]
if round(sum(cpixel)) / float(len(cpixel)) > 127:
    all_pixels.append(255)
else:
    all_pixels.append(0)
```